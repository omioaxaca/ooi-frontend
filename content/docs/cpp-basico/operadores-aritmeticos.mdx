---
title: "Operadores Aritm√©ticos"
description: "Aprende los operadores matem√°ticos en C++ incluyendo m√≥dulo, incremento y precedencia"
date: "2026-02-09"
author: "OOI Oaxaca"
tags: ["c++", "operadores", "aritm√©tica", "m√≥dulo"]
syllabusId: 8
---

## ¬øQu√© es un operador?

Un operador es un **s√≠mbolo** que le dice a la computadora que haga una operaci√≥n con uno o m√°s valores. Los m√°s b√°sicos son los que ya conoces de matem√°ticas: suma, resta, multiplicaci√≥n y divisi√≥n. Pero C++ tiene algunos operadores extra que son incre√≠blemente √∫tiles en programaci√≥n.

## Los operadores b√°sicos

### Suma `+`, Resta `-`, Multiplicaci√≥n `*`

Funcionan exactamente como en matem√°ticas:

```cpp
int a = 10, b = 3;

cout << a + b << endl;   // 13
cout << a - b << endl;   // 7
cout << a * b << endl;   // 30
```

Tambi√©n puedes usar el operador `-` para n√∫meros negativos:

```cpp
int x = -5;
cout << x << endl;      // -5
cout << -x << endl;     // 5 (el negativo de un negativo es positivo)
```

### Divisi√≥n `/`

Aqu√≠ hay un detalle **crucial**: la divisi√≥n entre enteros da un resultado entero (se trunca, no se redondea):

```cpp
int a = 7, b = 2;

cout << a / b << endl;       // 3 (no 3.5)
cout << 10 / 3 << endl;      // 3 (no 3.333...)
cout << 1 / 2 << endl;       // 0 (no 0.5)
cout << -7 / 2 << endl;      // -3 (trunca hacia cero)
```

Es como si la computadora hiciera la divisi√≥n y luego **cortara los decimales** (no redondea, sino que trunca hacia cero).

**Para obtener decimales**, al menos uno de los operandos debe ser `double`:

```cpp
cout << 7.0 / 2 << endl;       // 3.5
cout << 7 / 2.0 << endl;       // 3.5
cout << (double)7 / 2 << endl;  // 3.5
```

<Callout type="warning">
  **Dividir entre cero** causa un error fatal. Si `b` puede ser cero, siempre verifica antes de dividir: `if (b != 0) resultado = a / b;`
</Callout>

### El operador m√≥dulo `%` (residuo)

Este es un operador que probablemente no hayas visto en clase de matem√°ticas, pero es **uno de los m√°s importantes** en programaci√≥n competitiva.

El m√≥dulo (`%`) te da el **residuo** de una divisi√≥n entera. Es lo que "sobra" despu√©s de dividir:

```cpp
cout << 7 % 3 << endl;    // 1  (7 √∑ 3 = 2 con residuo 1)
cout << 10 % 5 << endl;   // 0  (10 √∑ 5 = 2 con residuo 0)
cout << 13 % 4 << endl;   // 1  (13 √∑ 4 = 3 con residuo 1)
cout << 3 % 7 << endl;    // 3  (3 √∑ 7 = 0 con residuo 3)
```

**Analog√≠a:** Imagina que tienes 7 galletas y quieres repartirlas entre 3 amigos por igual. Cada amigo recibe 2 galletas (eso es `7 / 3`), y **sobra 1** galleta (eso es `7 % 3`).

**Usos comunes del m√≥dulo:**

1. **¬øEs par o impar?**
   ```cpp
   if (n % 2 == 0) cout << "Par" << endl;
   else cout << "Impar" << endl;
   ```
   Si el residuo de dividir entre 2 es 0, es par.

2. **¬øEs divisible entre X?**
   ```cpp
   if (n % 3 == 0) cout << "Divisible entre 3" << endl;
   ```

3. **Obtener el √∫ltimo d√≠gito de un n√∫mero:**
   ```cpp
   int n = 12345;
   cout << n % 10 << endl;   // 5 (√∫ltimo d√≠gito)
   cout << n % 100 << endl;  // 45 (√∫ltimos dos d√≠gitos)
   ```

4. **Hacer que un n√∫mero "se enrolle" (wrap around):**
   ```cpp
   // Si tienes 7 d√≠as y quieres saber qu√© d√≠a de la semana es
   int diasTranscurridos = 10;
   int diaSemana = diasTranscurridos % 7;  // 3 (mi√©rcoles si empezamos en domingo=0)
   ```

5. **Aritm√©tica modular** (evitar n√∫meros gigantes):
   ```cpp
   // Los problemas piden la respuesta "m√≥dulo 10^9+7"
   int MOD = 1e9 + 7;
   long long resultado = (a * b) % MOD;
   ```

<Callout type="info">
  El operador `%` **solo funciona con enteros**. No puedes hacer `3.5 % 2`. Si necesitas el m√≥dulo de decimales, usa `fmod(3.5, 2.0)` de la biblioteca `<cmath>`.
</Callout>

## Operadores de asignaci√≥n compuesta

Cuando quieres modificar una variable, hay atajos muy √∫tiles:

```cpp
int x = 10;

x = x + 5;     // x ahora vale 15
x += 5;         // Equivalente: x ahora vale 20

x = x - 3;     // x ahora vale 17
x -= 3;         // Equivalente: x ahora vale 14

x = x * 2;     // x ahora vale 28
x *= 2;         // Equivalente: x ahora vale 56

x = x / 4;     // x ahora vale 14
x /= 4;         // Equivalente: x ahora vale 3 (truncado)

x = x % 2;     // x ahora vale 1
x %= 2;         // Equivalente: x ahora vale 1
```

| Atajo | Equivalencia |
|-------|-------------|
| `x += n` | `x = x + n` |
| `x -= n` | `x = x - n` |
| `x *= n` | `x = x * n` |
| `x /= n` | `x = x / n` |
| `x %= n` | `x = x % n` |

## Incremento `++` y Decremento `--`

Son atajos para sumar o restar 1:

```cpp
int x = 5;

x++;     // x ahora vale 6 (equivale a x = x + 1 o x += 1)
x++;     // x ahora vale 7
x--;     // x ahora vale 6 (equivale a x = x - 1 o x -= 1)
```

Hay dos versiones: **prefijo** (`++x`) y **posfijo** (`x++`). La diferencia importa cuando usas el operador dentro de una expresi√≥n:

```cpp
int a = 5;
int b = a++;   // b = 5, luego a sube a 6 (posfijo: usa primero, incrementa despu√©s)

int c = 5;
int d = ++c;   // c sube a 6 primero, luego d = 6 (prefijo: incrementa primero, usa despu√©s)
```

<Callout type="info">
  En la pr√°ctica, cuando usas `i++` o `++i` solos en una l√≠nea (no dentro de otra expresi√≥n), **no hay diferencia**. En los ciclos `for`, ambos funcionan igual: `for (int i = 0; i < n; i++)` y `for (int i = 0; i < n; ++i)` hacen lo mismo.
</Callout>

## Precedencia de operadores

Al igual que en matem√°ticas, los operadores tienen un **orden de prioridad**:

```cpp
int resultado = 2 + 3 * 4;    // ¬ø20 o 14?
cout << resultado << endl;     // 14 (multiplicaci√≥n va primero)
```

El orden de prioridad (de mayor a menor):

| Prioridad | Operadores | Ejemplo |
|-----------|-----------|---------|
| 1 (m√°s alta) | `()` Par√©ntesis | `(2 + 3) * 4 = 20` |
| 2 | `++` `--` (prefijo), `-` (negativo) | `++x`, `-x` |
| 3 | `*` `/` `%` | `6 / 2 * 3 = 9` |
| 4 | `+` `-` | `2 + 3 - 1 = 4` |
| 5 (m√°s baja) | `=` `+=` `-=` etc. | `x = 5` |

Cuando los operadores tienen la **misma prioridad**, se eval√∫an de **izquierda a derecha**:

```cpp
cout << 6 / 2 * 3 << endl;   // (6 / 2) * 3 = 9 (no 6 / 6 = 1)
cout << 10 - 3 + 2 << endl;  // (10 - 3) + 2 = 9 (no 10 - 5 = 5)
```

**Regla de oro:** Si no est√°s seguro del orden, **usa par√©ntesis**. Adem√°s, los par√©ntesis hacen el c√≥digo m√°s legible:

```cpp
// Sin par√©ntesis (correcto pero confuso)
int resultado = a + b * c - d / e % f;

// Con par√©ntesis (claro y seguro)
int resultado = a + (b * c) - ((d / e) % f);
```

## Funciones matem√°ticas √∫tiles

La biblioteca `<cmath>` (o `<bits/stdc++.h>`) te da funciones matem√°ticas:

```cpp
#include <cmath>

// Valor absoluto
cout << abs(-5) << endl;      // 5
cout << abs(5) << endl;       // 5

// Potencia: pow(base, exponente)
cout << pow(2, 10) << endl;   // 1024 (2^10)
cout << pow(3, 3) << endl;    // 27 (3^3)

// Ra√≠z cuadrada
cout << sqrt(25) << endl;     // 5
cout << sqrt(2) << endl;      // 1.41421...

// Redondeo
cout << ceil(3.2) << endl;    // 4 (redondear hacia arriba)
cout << floor(3.8) << endl;   // 3 (redondear hacia abajo)
cout << round(3.5) << endl;   // 4 (redondeo normal)

// M√≠nimo y m√°ximo
cout << min(3, 7) << endl;    // 3
cout << max(3, 7) << endl;    // 7
cout << min({5, 2, 8, 1}) << endl;  // 1 (m√≠nimo de varios)
```

<Callout type="warning">
  `pow()` devuelve un `double`, lo cual puede causar errores de precisi√≥n. `pow(2, 10)` podr√≠a dar `1023.9999999` que al convertir a `int` da `1023` en lugar de `1024`. Para potencias de enteros, es mejor multiplicar manualmente o escribir tu propia funci√≥n.
</Callout>

### Truco: potencia r√°pida para enteros

```cpp
// Mejor que pow() para enteros
long long potencia(long long base, int exp) {
    long long result = 1;
    for (int i = 0; i < exp; i++) {
        result *= base;
    }
    return result;
}
```

## Errores comunes con operadores

### 1. Overflow en multiplicaci√≥n

```cpp
int a = 100000, b = 100000;
int c = a * b;   // ‚ùå Overflow! 10^10 no cabe en int
long long d = (long long)a * b;  // ‚úÖ Correcto: 10000000000
```

### 2. Divisi√≥n entera cuando quer√≠as decimal

```cpp
int total = 7, n = 2;

// ‚ùå Incorrecto: 7 / 2 = 3 (entero)
double promedio = total / n;  // promedio = 3.0

// ‚úÖ Correcto: convertir a double primero
double promedio = (double)total / n;  // promedio = 3.5
```

### 3. M√≥dulo con n√∫meros negativos

```cpp
cout << -7 % 3 << endl;   // -1 (en C++, el signo sigue al dividendo)
cout << 7 % -3 << endl;   // 1
```

Si necesitas que el m√≥dulo siempre sea positivo:

```cpp
int mod_positivo = ((a % m) + m) % m;
```

## Ejemplo completo: desglosar billetes y monedas

**Problema:** Dado un precio en centavos, desglosa en monedas de $1 (100 centavos), $0.50 (50 centavos), $0.25 (25 centavos), $0.10 (10 centavos), $0.05 (5 centavos) y $0.01 (1 centavo), usando la menor cantidad de monedas posible.

**Entrada:** `347` (centavos)
**Salida:**
```
$1.00: 3
$0.50: 0
$0.25: 1
$0.10: 2
$0.05: 0
$0.01: 2
```

```cpp
#include <iostream>
using namespace std;

int main() {
    int centavos;
    cin >> centavos;

    cout << "$1.00: " << centavos / 100 << '\n';
    centavos %= 100;  // Queda el residuo

    cout << "$0.50: " << centavos / 50 << '\n';
    centavos %= 50;

    cout << "$0.25: " << centavos / 25 << '\n';
    centavos %= 25;

    cout << "$0.10: " << centavos / 10 << '\n';
    centavos %= 10;

    cout << "$0.05: " << centavos / 5 << '\n';
    centavos %= 5;

    cout << "$0.01: " << centavos << '\n';

    return 0;
}
```

**Paso a paso con 347 centavos:**
1. `347 / 100 = 3` billetes de $1. Quedan `347 % 100 = 47` centavos.
2. `47 / 50 = 0` monedas de 50¬¢. Quedan `47 % 50 = 47` centavos.
3. `47 / 25 = 1` moneda de 25¬¢. Quedan `47 % 25 = 22` centavos.
4. `22 / 10 = 2` monedas de 10¬¢. Quedan `22 % 10 = 2` centavos.
5. `2 / 5 = 0` monedas de 5¬¢. Quedan `2 % 5 = 2` centavos.
6. 2 centavos restantes = 2 monedas de 1¬¢.

## Ejercicio de pr√°ctica

Lee un n√∫mero de segundos y convi√©rtelo a horas, minutos y segundos.

**Entrada:** `3725`
**Salida:** `1 1 25` (1 hora, 1 minuto, 25 segundos)

<details>
<summary>Ver soluci√≥n</summary>

```cpp
#include <iostream>
using namespace std;

int main() {
    int totalSegundos;
    cin >> totalSegundos;

    int horas = totalSegundos / 3600;
    totalSegundos %= 3600;

    int minutos = totalSegundos / 60;
    int segundos = totalSegundos % 60;

    cout << horas << " " << minutos << " " << segundos << '\n';

    return 0;
}
```

**Explicaci√≥n:** 3725 √∑ 3600 = 1 hora, sobran 125 segundos. 125 √∑ 60 = 2 minutos, sobran 5 segundos. Resultado: 1 2 5.

¬°Espera, eso no coincide! Revisemos: 3725 = 3600 + 125 = 3600 + 60 + 65... no. 3725 = 1√ó3600 + 125. 125 = 2√ó60 + 5. Resultado: 1 2 5. (El ejemplo del enunciado tiene un error intencional para que lo pienses üòâ).

</details>

## Siguiente paso

Aprende sobre **Char y ASCII** para entender c√≥mo la computadora representa los caracteres como n√∫meros.
