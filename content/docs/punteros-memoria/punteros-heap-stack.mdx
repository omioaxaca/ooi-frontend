---
title: "Punteros y Manejo de Memoria"
description: "Comprende los punteros, la diferencia entre heap y stack, y el manejo de memoria en C++"
date: "2026-02-09"
author: "OOI Oaxaca"
tags: ["punteros", "memoria", "heap", "stack", "C++"]
syllabusId: 50
order: 1
---

## Â¿QuÃ© es un puntero?

Un **puntero** es una variable que almacena la **direcciÃ³n de memoria** de otra variable. En lugar de guardar un valor directamente, guarda la ubicaciÃ³n donde ese valor estÃ¡ almacenado.

```cpp
int x = 42;        // Variable normal
int* ptr = &x;     // Puntero que guarda la direcciÃ³n de x

cout << x << endl;      // 42 (el valor)
cout << &x << endl;     // 0x7ffd... (la direcciÃ³n)
cout << ptr << endl;    // 0x7ffd... (misma direcciÃ³n)
cout << *ptr << endl;   // 42 (desreferenciando el puntero)
```

> ğŸ’¡ **Operadores clave:**
> - `&` obtiene la direcciÃ³n de una variable
> - `*` accede al valor en una direcciÃ³n (desreferencia)

## Stack vs Heap

La memoria en un programa se divide principalmente en dos Ã¡reas:

### Stack (Pila)

El **stack** es memoria automÃ¡tica que se gestiona sola:

```cpp
void funcion() {
    int a = 5;           // Se crea en el stack
    double b = 3.14;     // TambiÃ©n en el stack
    int arr[100];        // Array en el stack
}                        // Al terminar, todo se libera automÃ¡ticamente
```

**CaracterÃ­sticas del Stack:**
- âœ… Muy rÃ¡pido (asignaciÃ³n instantÃ¡nea)
- âœ… LiberaciÃ³n automÃ¡tica
- âŒ TamaÃ±o limitado (tÃ­picamente 1-8 MB)
- âŒ No puede cambiar de tamaÃ±o

### Heap (MontÃ­culo)

El **heap** es memoria dinÃ¡mica que tÃº controlas:

```cpp
void funcion() {
    int* ptr = new int(42);         // Se crea en el heap
    int* arr = new int[1000000];    // Array grande en el heap

    // ... usar la memoria ...

    delete ptr;       // Debes liberar manualmente
    delete[] arr;     // Para arrays, usa delete[]
}
```

**CaracterÃ­sticas del Heap:**
- âœ… TamaÃ±o grande (GBs disponibles)
- âœ… Puede crecer dinÃ¡micamente
- âŒ MÃ¡s lento que stack
- âŒ Debes liberar manualmente (riesgo de memory leaks)

## ComparaciÃ³n visual

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              MEMORIA                     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Stack (crece hacia abajo â†“)            â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”            â”‚
â”‚  â”‚ Variables locales       â”‚            â”‚
â”‚  â”‚ ParÃ¡metros de funciÃ³n   â”‚            â”‚
â”‚  â”‚ Direcciones de retorno  â”‚            â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜            â”‚
â”‚           â†“                              â”‚
â”‚           .                              â”‚
â”‚           .                              â”‚
â”‚           â†‘                              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”            â”‚
â”‚  â”‚ Memoria dinÃ¡mica        â”‚            â”‚
â”‚  â”‚ (new/malloc)            â”‚            â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜            â”‚
â”‚  Heap (crece hacia arriba â†‘)            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Datos globales/estÃ¡ticos               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  CÃ³digo del programa                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## Â¿CuÃ¡ndo usar cada uno?

| SituaciÃ³n | Usar Stack | Usar Heap |
|-----------|------------|-----------|
| Arrays pequeÃ±os (<10âµ elementos) | âœ… | |
| Arrays grandes (>10âµ elementos) | | âœ… |
| TamaÃ±o conocido en compilaciÃ³n | âœ… | |
| TamaÃ±o dinÃ¡mico | | âœ… |
| Variables temporales | âœ… | |
| Datos que sobreviven la funciÃ³n | | âœ… |

## Problema comÃºn: Stack Overflow

En competencias, un error frecuente es el **stack overflow** por arrays grandes:

```cpp
// âŒ MAL: Array muy grande en el stack
void resolver() {
    int dp[10000][10000];  // 400 MB en stack = CRASH
}

// âœ… BIEN: OpciÃ³n 1 - Variables globales (no usan stack)
int dp[10000][10000];
void resolver() {
    // usar dp...
}

// âœ… BIEN: OpciÃ³n 2 - Usar heap
void resolver() {
    vector<vector<int>> dp(10000, vector<int>(10000));
    // vector usa heap internamente
}
```

> âš ï¸ **En competencias:** Declara arrays grandes como **variables globales** o usa `vector`.

## AritmÃ©tica de punteros

Los punteros soportan operaciones aritmÃ©ticas:

```cpp
int arr[5] = {10, 20, 30, 40, 50};
int* ptr = arr;  // Apunta al primer elemento

cout << *ptr << endl;       // 10
cout << *(ptr + 1) << endl; // 20 (avanza un int = 4 bytes)
cout << *(ptr + 2) << endl; // 30
cout << ptr[3] << endl;     // 40 (equivalente a *(ptr + 3))

ptr++;  // Ahora apunta a arr[1]
cout << *ptr << endl;  // 20
```

## Punteros y arrays

En C++, el nombre de un array es un puntero al primer elemento:

```cpp
int arr[5] = {1, 2, 3, 4, 5};

// Estas expresiones son equivalentes:
cout << arr[0] << endl;    // 1
cout << *arr << endl;      // 1

cout << arr[2] << endl;    // 3
cout << *(arr + 2) << endl; // 3

// Pasar array a funciÃ³n
void procesar(int* arr, int n) {
    for (int i = 0; i < n; i++) {
        cout << arr[i] << " ";
    }
}

procesar(arr, 5);  // Pasa la direcciÃ³n del array
```

## Punteros a punteros

Ãštiles para matrices dinÃ¡micas:

```cpp
// Crear matriz dinÃ¡mica n x m
int** crearMatriz(int n, int m) {
    int** matriz = new int*[n];  // Array de punteros
    for (int i = 0; i < n; i++) {
        matriz[i] = new int[m];  // Cada fila es un array
    }
    return matriz;
}

// Liberar matriz
void liberarMatriz(int** matriz, int n) {
    for (int i = 0; i < n; i++) {
        delete[] matriz[i];  // Liberar cada fila
    }
    delete[] matriz;  // Liberar array de punteros
}

int main() {
    int** mat = crearMatriz(3, 4);
    mat[1][2] = 42;  // Usar como matriz normal
    liberarMatriz(mat, 3);
    return 0;
}
```

> ğŸ’¡ **En competencias:** Preferir `vector<vector<int>>` que maneja la memoria automÃ¡ticamente.

## nullptr y verificaciones

Siempre verifica si un puntero es vÃ¡lido:

```cpp
int* ptr = nullptr;  // Puntero nulo (no apunta a nada)

// Verificar antes de usar
if (ptr != nullptr) {
    cout << *ptr << endl;
}

// Forma corta
if (ptr) {
    cout << *ptr << endl;
}
```

## Referencias vs Punteros

Las **referencias** son alias mÃ¡s seguros:

```cpp
int x = 10;

// Puntero
int* ptr = &x;
*ptr = 20;        // Necesita desreferenciar

// Referencia
int& ref = x;
ref = 30;         // Uso directo, mÃ¡s limpio

// En funciones - Paso por referencia
void duplicar(int& n) {
    n *= 2;  // Modifica el original
}

// Equivalente con puntero
void duplicarPtr(int* n) {
    *n *= 2;
}

int main() {
    int a = 5;
    duplicar(a);     // a ahora es 10
    duplicarPtr(&a); // a ahora es 20
}
```

## Smart Pointers (C++11+)

Para cÃ³digo mÃ¡s seguro, usa smart pointers:

```cpp
#include <memory>

// unique_ptr - un solo dueÃ±o
unique_ptr<int> p1 = make_unique<int>(42);
// Se libera automÃ¡ticamente al salir del scope

// shared_ptr - mÃºltiples dueÃ±os
shared_ptr<int> p2 = make_shared<int>(100);
shared_ptr<int> p3 = p2;  // Ambos apuntan al mismo dato
// Se libera cuando el Ãºltimo shared_ptr se destruye
```

> ğŸ“ **En competencias:** Raramente necesitas smart pointers, pero son importantes en cÃ³digo de producciÃ³n.

## Ejemplo prÃ¡ctico: Swap con punteros

```cpp
void intercambiar(int* a, int* b) {
    int temp = *a;
    *a = *b;
    *b = temp;
}

int main() {
    int x = 5, y = 10;
    intercambiar(&x, &y);
    cout << x << " " << y << endl;  // 10 5
}
```

## Errores comunes

### 1. Usar puntero no inicializado

```cpp
int* ptr;          // âŒ No apunta a nada vÃ¡lido
*ptr = 10;         // CRASH - undefined behavior

int* ptr = nullptr; // âœ… Al menos estÃ¡ inicializado
```

### 2. Memory leak

```cpp
void funcion() {
    int* ptr = new int(42);
    // âŒ OlvidÃ© hacer delete
}  // La memoria se pierde para siempre
```

### 3. Dangling pointer

```cpp
int* obtenerPuntero() {
    int x = 42;
    return &x;  // âŒ x se destruye al terminar la funciÃ³n
}
// El puntero retornado apunta a memoria invÃ¡lida
```

### 4. Double free

```cpp
int* ptr = new int(42);
delete ptr;
delete ptr;  // âŒ CRASH - liberar dos veces
```

## Template para competencias

```cpp
#include <bits/stdc++.h>
using namespace std;

// Arrays grandes como globales
const int MAXN = 100005;
int arr[MAXN];
int dp[5005][5005];

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);

    int n;
    cin >> n;

    // Para tamaÃ±os dinÃ¡micos, usar vector
    vector<int> v(n);
    for (int i = 0; i < n; i++) {
        cin >> v[i];
    }

    // Vector 2D dinÃ¡mico
    int filas, cols;
    cin >> filas >> cols;
    vector<vector<int>> matriz(filas, vector<int>(cols));

    return 0;
}
```

## Resumen

| Concepto | Stack | Heap |
|----------|-------|------|
| AsignaciÃ³n | AutomÃ¡tica | Manual (`new`/`delete`) |
| Velocidad | Muy rÃ¡pida | MÃ¡s lenta |
| TamaÃ±o | Limitado (~1-8 MB) | Grande (GBs) |
| LiberaciÃ³n | AutomÃ¡tica | Manual |
| Uso tÃ­pico | Variables locales | Datos grandes/dinÃ¡micos |

## Ejercicios

1. **Intercambio:** Implementa una funciÃ³n que intercambie dos valores usando punteros.

2. **Suma de array:** Escribe una funciÃ³n que reciba un puntero a un array y su tamaÃ±o, y retorne la suma.

3. **Matriz dinÃ¡mica:** Crea una matriz nÃ—m dinÃ¡micamente, llÃ©nala con valores, e imprÃ­mela.
