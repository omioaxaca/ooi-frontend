---
title: "Estructuras Persistentes"
description: "Estructuras de datos que guardan todas sus versiones anteriores"
date: "2026-02-09"
author: "OOI Oaxaca"
tags: ["c++", "persistente", "segment tree persistente", "versionado"]
syllabusId: 72
---

## ¿Qué son las estructuras persistentes?

**Analogía:** Imagina que escribes un documento en Google Docs. Cada vez que haces un cambio, Google guarda una versión. Puedes volver a cualquier versión anterior sin perder las actuales. Las **estructuras persistentes** hacen exactamente eso con datos: guardan todas las versiones.

En una estructura **normal**, cuando actualizas, pierdes el estado anterior. En una **persistente**, cada actualización crea una nueva versión sin destruir las anteriores.

## ¿Por qué es útil?

- Consultas históricas: "¿Cuál era el valor en la versión 5?"
- Problemas offline donde necesitas responder consultas sobre diferentes momentos.
- **K-ésimo menor en un rango**: el problema clásico.

## Idea clave: reutilizar nodos

Si un Segment Tree tiene $n$ hojas, una actualización solo modifica $O(\log n)$ nodos (el camino de la raíz a la hoja). Los demás nodos **no cambian**.

En vez de copiar todo el árbol ($O(n)$), solo creamos los nodos que cambian y reutilizamos los demás:

```
Versión 0:          Versión 1 (cambiar pos 3):
      A                    A'
     / \                  / \
    B    C               B    C'    ← B se reutiliza
   / \  / \             / \  / \
  D  E F  G            D  E F' G   ← D, E, G se reutilizan
```

Solo se crean A', C', F'. Los demás se comparten. Cada versión cuesta $O(\log n)$ nodos extra.

## Implementación: Segment Tree Persistente

En vez de usar un arreglo `tree[4*N]`, usamos nodos dinámicos con punteros (índices):

```cpp
const int MAXNODES = 20000005;  // Suficientes nodos

struct Node {
    int left, right;  // Índices de hijos
    long long val;
} nodes[MAXNODES];

int cnt = 0;  // Contador de nodos
int roots[200005];  // Raíz de cada versión

// Crear un nuevo nodo
int newNode() {
    cnt++;
    nodes[cnt] = {0, 0, 0};
    return cnt;
}

// Copiar un nodo existente
int copyNode(int v) {
    cnt++;
    nodes[cnt] = nodes[v];
    return cnt;
}
```

### Build (versión inicial)

```cpp
int build(int tl, int tr) {
    int v = newNode();

    if (tl == tr) {
        nodes[v].val = arr[tl];
        return v;
    }

    int tm = (tl + tr) / 2;
    nodes[v].left = build(tl, tm);
    nodes[v].right = build(tm + 1, tr);
    nodes[v].val = nodes[nodes[v].left].val + nodes[nodes[v].right].val;

    return v;
}
```

### Update (crear nueva versión)

```cpp
int update(int prev, int tl, int tr, int pos, long long val) {
    int v = copyNode(prev);  // Copiar el nodo actual

    if (tl == tr) {
        nodes[v].val = val;
        return v;
    }

    int tm = (tl + tr) / 2;
    if (pos <= tm) {
        // Solo cambia el hijo izquierdo
        nodes[v].left = update(nodes[prev].left, tl, tm, pos, val);
    } else {
        // Solo cambia el hijo derecho
        nodes[v].right = update(nodes[prev].right, tm + 1, tr, pos, val);
    }

    nodes[v].val = nodes[nodes[v].left].val + nodes[nodes[v].right].val;
    return v;
}
```

### Query (sobre cualquier versión)

```cpp
long long query(int v, int tl, int tr, int l, int r) {
    if (l > tr || r < tl) return 0;
    if (l <= tl && tr <= r) return nodes[v].val;

    int tm = (tl + tr) / 2;
    return query(nodes[v].left, tl, tm, l, r) +
           query(nodes[v].right, tm + 1, tr, l, r);
}
```

### Uso

```cpp
int main() {
    int n, q;
    cin >> n >> q;
    for (int i = 1; i <= n; i++) cin >> arr[i];

    // Versión 0: el arreglo original
    roots[0] = build(1, n);

    int version = 0;
    while (q--) {
        int tipo;
        cin >> tipo;

        if (tipo == 1) {
            // Consulta en versión v, rango [l, r]
            int v, l, r;
            cin >> v >> l >> r;
            cout << query(roots[v], 1, n, l, r) << "\n";
        } else {
            // Actualizar: crear nueva versión
            int pos;
            long long val;
            cin >> pos >> val;
            version++;
            roots[version] = update(roots[version - 1], 1, n, pos, val);
        }
    }

    return 0;
}
```

## Aplicación clásica: K-ésimo menor en un rango

Dado un arreglo, responder: ¿cuál es el k-ésimo menor valor en el rango `[l, r]`?

**Idea:** Construir un Segment Tree persistente sobre los **valores** (no posiciones). La versión `i` contiene las frecuencias de los primeros `i` elementos.

Para consultar `[l, r]`, restamos la versión `r` menos la versión `l-1`.

```cpp
const int MAXNODES = 20000005;

struct Node {
    int left, right, cnt;
} nodes[MAXNODES];

int cnt_nodes = 0;
int roots[200005];

int newNode() {
    cnt_nodes++;
    nodes[cnt_nodes] = {0, 0, 0};
    return cnt_nodes;
}

int build(int tl, int tr) {
    int v = newNode();
    if (tl == tr) return v;
    int tm = (tl + tr) / 2;
    nodes[v].left = build(tl, tm);
    nodes[v].right = build(tm + 1, tr);
    return v;
}

// Insertar un valor en la versión
int update(int prev, int tl, int tr, int pos) {
    int v = newNode();
    nodes[v] = nodes[prev];
    nodes[v].cnt++;

    if (tl == tr) return v;

    int tm = (tl + tr) / 2;
    if (pos <= tm)
        nodes[v].left = update(nodes[prev].left, tl, tm, pos);
    else
        nodes[v].right = update(nodes[prev].right, tm + 1, tr, pos);

    return v;
}

// K-ésimo menor entre versión vl y vr
int kth(int vl, int vr, int tl, int tr, int k) {
    if (tl == tr) return tl;

    int tm = (tl + tr) / 2;
    int leftCount = nodes[nodes[vr].left].cnt
                  - nodes[nodes[vl].left].cnt;

    if (k <= leftCount)
        return kth(nodes[vl].left, nodes[vr].left, tl, tm, k);
    else
        return kth(nodes[vl].right, nodes[vr].right, tm + 1, tr, k - leftCount);
}
```

<Callout type="info">
Este problema requiere **comprimir coordenadas** primero: mapear los valores a un rango `[1, M]` para que el Segment Tree no sea demasiado grande.
</Callout>

## Complejidad

| Operación | Tiempo | Espacio extra |
|-----------|--------|--------------|
| Build | $O(n)$ | $O(n)$ |
| Update (nueva versión) | $O(\log n)$ | $O(\log n)$ nodos |
| Query (cualquier versión) | $O(\log n)$ | — |
| Total con V versiones | — | $O(n + V \log n)$ |

<Callout type="warning">
La memoria es el cuello de botella. Con $n = 200000$ y $V = 200000$ versiones, necesitas ~$200000 \times 18 \approx 3.6M$ nodos. Asegúrate de declarar `MAXNODES` suficientemente grande.
</Callout>

## Ejercicio

Dado un arreglo de N enteros y Q consultas `(l, r, k)`, encuentra el k-ésimo menor en el rango `[l, r]`.

<details>
<summary>Ver solución</summary>

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

const int MAXN = 200005;
const int MAXNODES = MAXN * 20;

struct Node { int left, right, cnt; } nodes[MAXNODES];
int cntN = 0, roots[MAXN];

int newNode() { cntN++; nodes[cntN] = {0,0,0}; return cntN; }

int build(int tl, int tr) {
    int v = newNode();
    if (tl == tr) return v;
    int tm = (tl+tr)/2;
    nodes[v].left = build(tl, tm);
    nodes[v].right = build(tm+1, tr);
    return v;
}

int update(int prev, int tl, int tr, int pos) {
    int v = newNode();
    nodes[v] = nodes[prev];
    nodes[v].cnt++;
    if (tl == tr) return v;
    int tm = (tl+tr)/2;
    if (pos <= tm) nodes[v].left = update(nodes[prev].left, tl, tm, pos);
    else nodes[v].right = update(nodes[prev].right, tm+1, tr, pos);
    return v;
}

int kth(int vl, int vr, int tl, int tr, int k) {
    if (tl == tr) return tl;
    int tm = (tl+tr)/2;
    int lc = nodes[nodes[vr].left].cnt - nodes[nodes[vl].left].cnt;
    if (k <= lc) return kth(nodes[vl].left, nodes[vr].left, tl, tm, k);
    return kth(nodes[vl].right, nodes[vr].right, tm+1, tr, k-lc);
}

int main() {
    int n, q;
    cin >> n >> q;

    vector<int> v(n+1), sorted_v;
    for (int i = 1; i <= n; i++) {
        cin >> v[i];
        sorted_v.push_back(v[i]);
    }

    sort(sorted_v.begin(), sorted_v.end());
    sorted_v.erase(unique(sorted_v.begin(), sorted_v.end()), sorted_v.end());
    int M = sorted_v.size();

    roots[0] = build(1, M);
    for (int i = 1; i <= n; i++) {
        int pos = lower_bound(sorted_v.begin(), sorted_v.end(), v[i])
                  - sorted_v.begin() + 1;
        roots[i] = update(roots[i-1], 1, M, pos);
    }

    while (q--) {
        int l, r, k;
        cin >> l >> r >> k;
        int idx = kth(roots[l-1], roots[r], 1, M, k);
        cout << sorted_v[idx - 1] << "\n";
    }

    return 0;
}
```

</details>
