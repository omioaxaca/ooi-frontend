---
title: "BFS - Búsqueda en Anchura"
description: "Aprende el algoritmo BFS para recorrer grafos y encontrar caminos mínimos"
date: "2026-02-09"
author: "OOI Oaxaca"
tags: ["grafos", "BFS", "recorrido", "camino-mínimo"]
syllabusId: 75
order: 2
---

## ¿Qué es BFS?

**BFS (Breadth-First Search)** es un algoritmo que recorre un grafo nivel por nivel, explorando primero todos los vecinos antes de pasar a los vecinos de los vecinos.

## Características

- Usa una **cola (queue)** para procesar nodos
- Encuentra el **camino más corto** en grafos sin peso
- Complejidad: **O(V + E)**

## Implementación básica

```cpp
#include <bits/stdc++.h>
using namespace std;

const int MAXN = 100005;
vector<int> adj[MAXN];
bool visitado[MAXN];
int distancia[MAXN];

void bfs(int inicio) {
    queue<int> q;
    q.push(inicio);
    visitado[inicio] = true;
    distancia[inicio] = 0;

    while (!q.empty()) {
        int actual = q.front();
        q.pop();

        for (int vecino : adj[actual]) {
            if (!visitado[vecino]) {
                visitado[vecino] = true;
                distancia[vecino] = distancia[actual] + 1;
                q.push(vecino);
            }
        }
    }
}

int main() {
    int n, m;
    cin >> n >> m;

    for (int i = 0; i < m; i++) {
        int u, v;
        cin >> u >> v;
        adj[u].push_back(v);
        adj[v].push_back(u);
    }

    bfs(1);

    // Distancia del nodo 1 a todos los demás
    for (int i = 1; i <= n; i++) {
        cout << "Distancia a " << i << ": " << distancia[i] << "\n";
    }

    return 0;
}
```

## Reconstruir camino

Para obtener el camino, guardamos el padre de cada nodo:

```cpp
int padre[MAXN];

void bfs(int inicio) {
    queue<int> q;
    q.push(inicio);
    visitado[inicio] = true;
    padre[inicio] = -1;

    while (!q.empty()) {
        int actual = q.front();
        q.pop();

        for (int vecino : adj[actual]) {
            if (!visitado[vecino]) {
                visitado[vecino] = true;
                padre[vecino] = actual;
                q.push(vecino);
            }
        }
    }
}

vector<int> reconstruirCamino(int destino) {
    vector<int> camino;

    if (!visitado[destino]) return camino;  // No existe camino

    for (int v = destino; v != -1; v = padre[v]) {
        camino.push_back(v);
    }

    reverse(camino.begin(), camino.end());
    return camino;
}
```

## BFS en matriz (grid)

Muy común en problemas de laberintos:

```cpp
int n, m;
char grid[1005][1005];
int dist[1005][1005];

int dx[] = {0, 0, 1, -1};  // Direcciones: derecha, izquierda, abajo, arriba
int dy[] = {1, -1, 0, 0};

bool valido(int x, int y) {
    return x >= 0 && x < n && y >= 0 && y < m && grid[x][y] != '#';
}

int bfsGrid(int inicioX, int inicioY, int finX, int finY) {
    memset(dist, -1, sizeof(dist));

    queue<pair<int, int>> q;
    q.push({inicioX, inicioY});
    dist[inicioX][inicioY] = 0;

    while (!q.empty()) {
        auto [x, y] = q.front();
        q.pop();

        if (x == finX && y == finY) {
            return dist[x][y];
        }

        for (int d = 0; d < 4; d++) {
            int nx = x + dx[d];
            int ny = y + dy[d];

            if (valido(nx, ny) && dist[nx][ny] == -1) {
                dist[nx][ny] = dist[x][y] + 1;
                q.push({nx, ny});
            }
        }
    }

    return -1;  // No hay camino
}
```

## BFS 0-1

Para grafos donde las aristas tienen peso 0 o 1, usamos un **deque**:

```cpp
int bfs01(int inicio, int fin) {
    vector<int> dist(n + 1, INT_MAX);
    deque<int> dq;

    dist[inicio] = 0;
    dq.push_front(inicio);

    while (!dq.empty()) {
        int u = dq.front();
        dq.pop_front();

        for (auto [v, peso] : adj[u]) {  // adj tiene {vecino, peso}
            if (dist[u] + peso < dist[v]) {
                dist[v] = dist[u] + peso;
                if (peso == 0) {
                    dq.push_front(v);  // Peso 0: al frente
                } else {
                    dq.push_back(v);   // Peso 1: al final
                }
            }
        }
    }

    return dist[fin];
}
```

## BFS Multi-fuente

Iniciar BFS desde múltiples nodos simultáneamente:

```cpp
void bfsMultiFuente(vector<int>& fuentes) {
    queue<int> q;

    for (int s : fuentes) {
        q.push(s);
        visitado[s] = true;
        distancia[s] = 0;
    }

    while (!q.empty()) {
        int actual = q.front();
        q.pop();

        for (int vecino : adj[actual]) {
            if (!visitado[vecino]) {
                visitado[vecino] = true;
                distancia[vecino] = distancia[actual] + 1;
                q.push(vecino);
            }
        }
    }
}
```

## Problema: Contar componentes conexas

```cpp
int contarComponentes(int n) {
    int componentes = 0;

    for (int i = 1; i <= n; i++) {
        if (!visitado[i]) {
            bfs(i);
            componentes++;
        }
    }

    return componentes;
}
```

## Template completo

```cpp
#include <bits/stdc++.h>
using namespace std;

const int MAXN = 100005;
vector<int> adj[MAXN];
bool visitado[MAXN];
int distancia[MAXN], padre[MAXN];

void bfs(int inicio) {
    queue<int> q;
    q.push(inicio);
    visitado[inicio] = true;
    distancia[inicio] = 0;
    padre[inicio] = -1;

    while (!q.empty()) {
        int u = q.front();
        q.pop();

        for (int v : adj[u]) {
            if (!visitado[v]) {
                visitado[v] = true;
                distancia[v] = distancia[u] + 1;
                padre[v] = u;
                q.push(v);
            }
        }
    }
}

vector<int> getCamino(int destino) {
    vector<int> camino;
    if (!visitado[destino]) return camino;
    for (int v = destino; v != -1; v = padre[v]) {
        camino.push_back(v);
    }
    reverse(camino.begin(), camino.end());
    return camino;
}

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);

    int n, m;
    cin >> n >> m;

    for (int i = 0; i < m; i++) {
        int u, v;
        cin >> u >> v;
        adj[u].push_back(v);
        adj[v].push_back(u);
    }

    bfs(1);

    // Imprimir distancias
    for (int i = 1; i <= n; i++) {
        if (visitado[i]) {
            cout << distancia[i] << " ";
        } else {
            cout << -1 << " ";
        }
    }

    return 0;
}
```

## Ejercicios recomendados

1. [CSES - Labyrinth](https://cses.fi/problemset/task/1193)
2. [CSES - Message Route](https://cses.fi/problemset/task/1667)
3. [CSES - Monsters](https://cses.fi/problemset/task/1194)
4. [Codeforces - Three States](https://codeforces.com/problemset/problem/590/C)
5. [LeetCode - Shortest Path in Binary Matrix](https://leetcode.com/problems/shortest-path-in-binary-matrix/)
