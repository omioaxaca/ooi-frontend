---
title: "B√∫squeda Binaria"
description: "Domina la t√©cnica de b√∫squeda binaria y sus variantes para resolver problemas eficientemente"
date: "2026-02-09"
author: "OOI Oaxaca"
tags: ["b√∫squeda", "binaria", "algoritmos", "divide-y-vencer√°s"]
syllabusId: 42
order: 1
---

## ¬øQu√© es la b√∫squeda binaria?

La b√∫squeda binaria es un algoritmo eficiente para encontrar un elemento en una colecci√≥n **ordenada**. En cada paso, divide el espacio de b√∫squeda a la mitad, logrando una complejidad de **O(log n)**.

> üìù **Nota:** La b√∫squeda binaria requiere que los datos est√©n ordenados. Si no lo est√°n, primero debes ordenarlos con un costo de O(n log n).

## Implementaci√≥n b√°sica

### Encontrar un elemento

```cpp
int busquedaBinaria(vector<int>& arr, int objetivo) {
    int izq = 0;
    int der = arr.size() - 1;

    while (izq <= der) {
        int mid = izq + (der - izq) / 2;  // Evita overflow

        if (arr[mid] == objetivo) {
            return mid;  // Encontrado
        }

        if (arr[mid] < objetivo) {
            izq = mid + 1;  // Buscar en la mitad derecha
        } else {
            der = mid - 1;  // Buscar en la mitad izquierda
        }
    }

    return -1;  // No encontrado
}
```

### Implementaci√≥n recursiva

```cpp
int busquedaBinariaRecursiva(vector<int>& arr, int objetivo, int izq, int der) {
    if (izq > der) return -1;

    int mid = izq + (der - izq) / 2;

    if (arr[mid] == objetivo) return mid;

    if (arr[mid] < objetivo) {
        return busquedaBinariaRecursiva(arr, objetivo, mid + 1, der);
    } else {
        return busquedaBinariaRecursiva(arr, objetivo, izq, mid - 1);
    }
}
```

## Variantes importantes

### Lower Bound

Encuentra la primera posici√≥n donde se puede insertar un elemento manteniendo el orden (primer elemento ‚â• objetivo).

```cpp
int lowerBound(vector<int>& arr, int objetivo) {
    int izq = 0, der = arr.size();

    while (izq < der) {
        int mid = izq + (der - izq) / 2;

        if (arr[mid] < objetivo) {
            izq = mid + 1;
        } else {
            der = mid;
        }
    }

    return izq;
}
```

### Upper Bound

Encuentra la primera posici√≥n con un elemento mayor que el objetivo.

```cpp
int upperBound(vector<int>& arr, int objetivo) {
    int izq = 0, der = arr.size();

    while (izq < der) {
        int mid = izq + (der - izq) / 2;

        if (arr[mid] <= objetivo) {
            izq = mid + 1;
        } else {
            der = mid;
        }
    }

    return izq;
}
```

## Usando la STL de C++

La biblioteca est√°ndar ya incluye estas funciones:

```cpp
#include <algorithm>

vector<int> arr = {1, 2, 4, 4, 4, 5, 6};

// Buscar si existe el elemento 4
bool existe = binary_search(arr.begin(), arr.end(), 4);  // true

// Lower bound: primer elemento >= 4
auto it1 = lower_bound(arr.begin(), arr.end(), 4);
int pos1 = it1 - arr.begin();  // pos1 = 2

// Upper bound: primer elemento > 4
auto it2 = upper_bound(arr.begin(), arr.end(), 4);
int pos2 = it2 - arr.begin();  // pos2 = 5

// Contar ocurrencias de 4
int cuenta = upper_bound(arr.begin(), arr.end(), 4) -
             lower_bound(arr.begin(), arr.end(), 4);  // cuenta = 3
```

## B√∫squeda binaria sobre la respuesta

Una t√©cnica poderosa es aplicar b√∫squeda binaria no sobre un array, sino sobre el rango de posibles respuestas.

### Ejemplo: Tiempo m√≠nimo para completar tareas

**Problema:** Tienes n trabajadores que pueden completar una tarea en tiempos `t[i]`. ¬øCu√°l es el tiempo m√≠nimo para completar m tareas?

```cpp
bool esPosible(vector<int>& tiempos, int m, long long tiempo) {
    long long tareas = 0;
    for (int t : tiempos) {
        tareas += tiempo / t;
        if (tareas >= m) return true;
    }
    return false;
}

long long tiempoMinimo(vector<int>& tiempos, int m) {
    long long izq = 1;
    long long der = 1e18;  // L√≠mite superior seguro

    while (izq < der) {
        long long mid = izq + (der - izq) / 2;

        if (esPosible(tiempos, m, mid)) {
            der = mid;
        } else {
            izq = mid + 1;
        }
    }

    return izq;
}
```

> ‚úÖ Esta t√©cnica se conoce como "Binary Search on Answer" y es extremadamente √∫til en competencias.

## B√∫squeda binaria en n√∫meros reales

Para b√∫squeda en n√∫meros reales, usamos un n√∫mero fijo de iteraciones o una tolerancia:

```cpp
double raizCuadrada(double n) {
    double izq = 0, der = n;

    // 100 iteraciones garantizan suficiente precisi√≥n
    for (int i = 0; i < 100; i++) {
        double mid = (izq + der) / 2;

        if (mid * mid <= n) {
            izq = mid;
        } else {
            der = mid;
        }
    }

    return izq;
}
```

## Errores comunes

> ‚ö†Ô∏è **Cuidado:** Evita estos errores frecuentes en b√∫squeda binaria.

### 1. Overflow en el c√°lculo de mid

```cpp
// ‚ùå Mal: puede causar overflow
int mid = (izq + der) / 2;

// ‚úÖ Bien: evita overflow
int mid = izq + (der - izq) / 2;
```

### 2. Loop infinito

```cpp
// ‚ùå Mal: si izq = der - 1, mid = izq siempre
while (izq < der) {
    int mid = (izq + der) / 2;
    if (condicion) izq = mid;  // ¬°Nunca avanza!
    else der = mid;
}

// ‚úÖ Bien: usar mid + 1
while (izq < der) {
    int mid = izq + (der - izq) / 2;
    if (condicion) izq = mid + 1;
    else der = mid;
}
```

### 3. L√≠mites incorrectos

Siempre verifica que tu rango de b√∫squeda incluya todas las posibles respuestas.

## Template completo

```cpp
#include <bits/stdc++.h>
using namespace std;

// B√∫squeda binaria est√°ndar
int buscar(vector<int>& arr, int x) {
    int izq = 0, der = arr.size() - 1;
    while (izq <= der) {
        int mid = izq + (der - izq) / 2;
        if (arr[mid] == x) return mid;
        if (arr[mid] < x) izq = mid + 1;
        else der = mid - 1;
    }
    return -1;
}

// B√∫squeda binaria sobre respuesta
// Encuentra m√≠nimo x tal que f(x) es true
template<typename F>
long long buscarMinimo(long long lo, long long hi, F condicion) {
    while (lo < hi) {
        long long mid = lo + (hi - lo) / 2;
        if (condicion(mid)) {
            hi = mid;
        } else {
            lo = mid + 1;
        }
    }
    return lo;
}

// Encuentra m√°ximo x tal que f(x) es true
template<typename F>
long long buscarMaximo(long long lo, long long hi, F condicion) {
    while (lo < hi) {
        long long mid = lo + (hi - lo + 1) / 2;  // Nota el +1
        if (condicion(mid)) {
            lo = mid;
        } else {
            hi = mid - 1;
        }
    }
    return lo;
}

int main() {
    vector<int> arr = {1, 3, 5, 7, 9, 11};

    cout << buscar(arr, 7) << endl;  // 3

    // Encontrar m√≠nimo x tal que x*x >= 50
    auto resultado = buscarMinimo(1LL, 100LL, [](long long x) {
        return x * x >= 50;
    });
    cout << resultado << endl;  // 8

    return 0;
}
```

## Ejercicio pr√°ctico

**Problema:** Dado un array ordenado, encuentra el n√∫mero de elementos en el rango [a, b].

```cpp
int contarEnRango(vector<int>& arr, int a, int b) {
    // Tu c√≥digo aqu√≠
}
```

<details>
<summary>Ver soluci√≥n</summary>

```cpp
int contarEnRango(vector<int>& arr, int a, int b) {
    auto inicio = lower_bound(arr.begin(), arr.end(), a);
    auto fin = upper_bound(arr.begin(), arr.end(), b);
    return fin - inicio;
}
```

</details>

## Resumen

| Variante | Descripci√≥n | Complejidad |
|----------|-------------|-------------|
| B√∫squeda est√°ndar | Encontrar elemento exacto | $O(\log n)$ |
| Lower bound | Primer elemento ‚â• x | $O(\log n)$ |
| Upper bound | Primer elemento > x | $O(\log n)$ |
| Binary search on answer | Buscar valor √≥ptimo | $O(\log R \cdot f(n))$ |

## Ejercicios recomendados

1. [CSES - Factory Machines](https://cses.fi/problemset/task/1620)
2. [SPOJ - Aggressive Cows](https://www.spoj.com/problems/AGGRCOW/)
3. [Codeforces - Hamburgers](https://codeforces.com/problemset/problem/371/C)
4. [AtCoder - Snuke's Coloring](https://atcoder.jp/contests/abc155/tasks/abc155_d)
