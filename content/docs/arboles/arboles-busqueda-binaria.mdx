---
title: "√Årboles Binarios de B√∫squeda (BST)"
description: "Domina los √°rboles binarios de b√∫squeda: operaciones, propiedades y aplicaciones"
date: "2026-02-09"
author: "OOI Oaxaca"
tags: ["BST", "√°rboles", "b√∫squeda", "estructuras-de-datos"]
syllabusId: 56
order: 4
---

## ¬øQu√© es un BST?

Un **√Årbol Binario de B√∫squeda** (Binary Search Tree) es un √°rbol binario donde para cada nodo:

- Todos los valores en el sub√°rbol **izquierdo** son **menores**
- Todos los valores en el sub√°rbol **derecho** son **mayores**

```
        8
       / \
      3   10
     / \    \
    1   6    14
       / \   /
      4   7 13

Propiedad BST:
- Izquierda de 8: {1, 3, 4, 6, 7} (todos < 8)
- Derecha de 8: {10, 13, 14} (todos > 8)
```

## Operaciones y complejidad

| Operaci√≥n | Promedio | Peor caso |
|-----------|----------|-----------|
| B√∫squeda | $O(\log n)$ | $O(n)$ |
| Inserci√≥n | $O(\log n)$ | $O(n)$ |
| Eliminaci√≥n | $O(\log n)$ | $O(n)$ |
| M√≠nimo/M√°ximo | $O(\log n)$ | $O(n)$ |

> ‚ö†Ô∏è El peor caso ocurre cuando el √°rbol est√° **degenerado** (parece una lista).

## Estructura del nodo

```cpp
struct Nodo {
    int valor;
    Nodo* izquierdo;
    Nodo* derecho;

    Nodo(int v) : valor(v), izquierdo(nullptr), derecho(nullptr) {}
};
```

## Operaciones b√°sicas

### B√∫squeda

```cpp
Nodo* buscar(Nodo* raiz, int valor) {
    if (raiz == nullptr || raiz->valor == valor) {
        return raiz;
    }

    if (valor < raiz->valor) {
        return buscar(raiz->izquierdo, valor);
    } else {
        return buscar(raiz->derecho, valor);
    }
}

// Versi√≥n iterativa
Nodo* buscarIterativo(Nodo* raiz, int valor) {
    while (raiz != nullptr && raiz->valor != valor) {
        if (valor < raiz->valor) {
            raiz = raiz->izquierdo;
        } else {
            raiz = raiz->derecho;
        }
    }
    return raiz;
}
```

### Inserci√≥n

```cpp
Nodo* insertar(Nodo* raiz, int valor) {
    if (raiz == nullptr) {
        return new Nodo(valor);
    }

    if (valor < raiz->valor) {
        raiz->izquierdo = insertar(raiz->izquierdo, valor);
    } else if (valor > raiz->valor) {
        raiz->derecho = insertar(raiz->derecho, valor);
    }
    // Si valor == raiz->valor, no hacemos nada (sin duplicados)

    return raiz;
}
```

### M√≠nimo y M√°ximo

```cpp
Nodo* minimo(Nodo* raiz) {
    if (raiz == nullptr) return nullptr;

    while (raiz->izquierdo != nullptr) {
        raiz = raiz->izquierdo;
    }
    return raiz;
}

Nodo* maximo(Nodo* raiz) {
    if (raiz == nullptr) return nullptr;

    while (raiz->derecho != nullptr) {
        raiz = raiz->derecho;
    }
    return raiz;
}
```

### Eliminaci√≥n

La eliminaci√≥n tiene tres casos:

```cpp
Nodo* eliminar(Nodo* raiz, int valor) {
    if (raiz == nullptr) return nullptr;

    if (valor < raiz->valor) {
        raiz->izquierdo = eliminar(raiz->izquierdo, valor);
    } else if (valor > raiz->valor) {
        raiz->derecho = eliminar(raiz->derecho, valor);
    } else {
        // Encontramos el nodo a eliminar

        // Caso 1: Hoja (sin hijos)
        if (raiz->izquierdo == nullptr && raiz->derecho == nullptr) {
            delete raiz;
            return nullptr;
        }

        // Caso 2: Un solo hijo
        if (raiz->izquierdo == nullptr) {
            Nodo* temp = raiz->derecho;
            delete raiz;
            return temp;
        }
        if (raiz->derecho == nullptr) {
            Nodo* temp = raiz->izquierdo;
            delete raiz;
            return temp;
        }

        // Caso 3: Dos hijos
        // Reemplazar con el sucesor inorder (m√≠nimo del sub√°rbol derecho)
        Nodo* sucesor = minimo(raiz->derecho);
        raiz->valor = sucesor->valor;
        raiz->derecho = eliminar(raiz->derecho, sucesor->valor);
    }

    return raiz;
}
```

### Visualizaci√≥n de eliminaci√≥n

```
Eliminar 3:

        8                    8
       / \                  / \
      3   10      ‚Üí        4   10
     / \    \             / \    \
    1   6    14          1   6    14
       / \   /              / \   /
      4   7 13             5   7 13

Caso 3: 3 tiene dos hijos
‚Üí Reemplazar con sucesor (4)
‚Üí Eliminar 4 de su posici√≥n original
```

## Recorrido Inorder = Ordenado

Una propiedad fundamental: el recorrido inorder de un BST produce los elementos **ordenados**:

```cpp
void inorder(Nodo* raiz) {
    if (raiz == nullptr) return;

    inorder(raiz->izquierdo);
    cout << raiz->valor << " ";
    inorder(raiz->derecho);
}

// Para el √°rbol de ejemplo: 1, 3, 4, 6, 7, 8, 10, 13, 14
```

## Sucesor y Predecesor

### Sucesor Inorder

El menor valor mayor que el dado:

```cpp
Nodo* sucesor(Nodo* raiz, int valor) {
    Nodo* sucesor = nullptr;
    Nodo* actual = raiz;

    while (actual != nullptr) {
        if (valor < actual->valor) {
            sucesor = actual;  // Posible sucesor
            actual = actual->izquierdo;
        } else {
            actual = actual->derecho;
        }
    }

    return sucesor;
}
```

### Predecesor Inorder

El mayor valor menor que el dado:

```cpp
Nodo* predecesor(Nodo* raiz, int valor) {
    Nodo* predecesor = nullptr;
    Nodo* actual = raiz;

    while (actual != nullptr) {
        if (valor > actual->valor) {
            predecesor = actual;
            actual = actual->derecho;
        } else {
            actual = actual->izquierdo;
        }
    }

    return predecesor;
}
```

## Validar si es BST

```cpp
bool esBSTUtil(Nodo* nodo, long long minVal, long long maxVal) {
    if (nodo == nullptr) return true;

    if (nodo->valor <= minVal || nodo->valor >= maxVal) {
        return false;
    }

    return esBSTUtil(nodo->izquierdo, minVal, nodo->valor) &&
           esBSTUtil(nodo->derecho, nodo->valor, maxVal);
}

bool esBST(Nodo* raiz) {
    return esBSTUtil(raiz, LLONG_MIN, LLONG_MAX);
}
```

## Operaciones adicionales

### K-√©simo elemento m√°s peque√±o

```cpp
int kEsimo(Nodo* raiz, int& k) {
    if (raiz == nullptr) return -1;

    // Buscar en sub√°rbol izquierdo
    int izq = kEsimo(raiz->izquierdo, k);
    if (izq != -1) return izq;

    // Verificar nodo actual
    k--;
    if (k == 0) return raiz->valor;

    // Buscar en sub√°rbol derecho
    return kEsimo(raiz->derecho, k);
}

// Uso
int k = 3;
int resultado = kEsimo(raiz, k);  // 3er elemento m√°s peque√±o
```

### Contar nodos en rango [lo, hi]

```cpp
int contarEnRango(Nodo* raiz, int lo, int hi) {
    if (raiz == nullptr) return 0;

    if (raiz->valor < lo) {
        return contarEnRango(raiz->derecho, lo, hi);
    }

    if (raiz->valor > hi) {
        return contarEnRango(raiz->izquierdo, lo, hi);
    }

    return 1 + contarEnRango(raiz->izquierdo, lo, hi) +
               contarEnRango(raiz->derecho, lo, hi);
}
```

### LCA (Lowest Common Ancestor)

```cpp
Nodo* lca(Nodo* raiz, int p, int q) {
    if (raiz == nullptr) return nullptr;

    if (p < raiz->valor && q < raiz->valor) {
        return lca(raiz->izquierdo, p, q);
    }

    if (p > raiz->valor && q > raiz->valor) {
        return lca(raiz->derecho, p, q);
    }

    return raiz;  // p y q est√°n en diferentes lados
}
```

## Usando set/map de STL

En competencias, `set` y `map` de C++ son BST balanceados (red-black trees):

```cpp
#include <set>
#include <map>

int main() {
    set<int> s;

    s.insert(5);
    s.insert(3);
    s.insert(8);
    s.insert(1);

    // Iteraci√≥n en orden
    for (int x : s) {
        cout << x << " ";  // 1 3 5 8
    }

    // B√∫squeda O(log n)
    if (s.count(3)) {
        cout << "3 existe" << endl;
    }

    // Lower bound: primer elemento >= x
    auto it = s.lower_bound(4);  // Apunta a 5

    // Upper bound: primer elemento > x
    auto it2 = s.upper_bound(3);  // Apunta a 5

    // M√≠nimo y m√°ximo
    cout << *s.begin() << endl;   // 1 (m√≠nimo)
    cout << *s.rbegin() << endl;  // 8 (m√°ximo)

    // Eliminar
    s.erase(5);

    return 0;
}
```

### multiset (permite duplicados)

```cpp
multiset<int> ms;
ms.insert(5);
ms.insert(5);
ms.insert(5);

cout << ms.count(5) << endl;  // 3

ms.erase(ms.find(5));  // Eliminar UNA ocurrencia
cout << ms.count(5) << endl;  // 2

ms.erase(5);  // Eliminar TODAS las ocurrencias
cout << ms.count(5) << endl;  // 0
```

## Clase BST completa

```cpp
class BST {
private:
    Nodo* raiz;

    Nodo* insertarRec(Nodo* nodo, int valor) {
        if (nodo == nullptr) return new Nodo(valor);
        if (valor < nodo->valor) nodo->izquierdo = insertarRec(nodo->izquierdo, valor);
        else if (valor > nodo->valor) nodo->derecho = insertarRec(nodo->derecho, valor);
        return nodo;
    }

    Nodo* eliminarRec(Nodo* nodo, int valor) {
        if (nodo == nullptr) return nullptr;

        if (valor < nodo->valor) {
            nodo->izquierdo = eliminarRec(nodo->izquierdo, valor);
        } else if (valor > nodo->valor) {
            nodo->derecho = eliminarRec(nodo->derecho, valor);
        } else {
            if (nodo->izquierdo == nullptr) {
                Nodo* temp = nodo->derecho;
                delete nodo;
                return temp;
            }
            if (nodo->derecho == nullptr) {
                Nodo* temp = nodo->izquierdo;
                delete nodo;
                return temp;
            }
            Nodo* sucesor = nodo->derecho;
            while (sucesor->izquierdo) sucesor = sucesor->izquierdo;
            nodo->valor = sucesor->valor;
            nodo->derecho = eliminarRec(nodo->derecho, sucesor->valor);
        }
        return nodo;
    }

    void inorderRec(Nodo* nodo) {
        if (nodo == nullptr) return;
        inorderRec(nodo->izquierdo);
        cout << nodo->valor << " ";
        inorderRec(nodo->derecho);
    }

public:
    BST() : raiz(nullptr) {}

    void insertar(int valor) { raiz = insertarRec(raiz, valor); }
    void eliminar(int valor) { raiz = eliminarRec(raiz, valor); }

    bool buscar(int valor) {
        Nodo* actual = raiz;
        while (actual) {
            if (valor == actual->valor) return true;
            actual = valor < actual->valor ? actual->izquierdo : actual->derecho;
        }
        return false;
    }

    void imprimir() { inorderRec(raiz); cout << endl; }
};

int main() {
    BST arbol;
    arbol.insertar(8);
    arbol.insertar(3);
    arbol.insertar(10);
    arbol.insertar(1);
    arbol.insertar(6);

    arbol.imprimir();  // 1 3 6 8 10

    cout << arbol.buscar(6) << endl;  // 1 (true)

    arbol.eliminar(3);
    arbol.imprimir();  // 1 6 8 10

    return 0;
}
```

## Resumen

| Operaci√≥n | BST simple | set/map de STL |
|-----------|------------|----------------|
| Insertar | $O(\log n)$ - $O(n)$ | $O(\log n)$ garantizado |
| Buscar | $O(\log n)$ - $O(n)$ | $O(\log n)$ garantizado |
| Eliminar | $O(\log n)$ - $O(n)$ | $O(\log n)$ garantizado |

> üí° **En competencias:** Usa `set` y `map` de STL. Son BST balanceados con garant√≠a de $O(\log n)$.

## Ejercicios recomendados

1. [LeetCode - Validate BST](https://leetcode.com/problems/validate-binary-search-tree/)
2. [LeetCode - Kth Smallest Element in BST](https://leetcode.com/problems/kth-smallest-element-in-a-bst/)
3. [LeetCode - LCA of BST](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/)
4. [LeetCode - Delete Node in BST](https://leetcode.com/problems/delete-node-in-a-bst/)
5. [CSES - Distinct Numbers](https://cses.fi/problemset/task/1621)
