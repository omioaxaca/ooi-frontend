---
title: "Teoría de Juegos"
description: "Juegos combinatorios, posiciones ganadoras y perdedoras, y el teorema de Sprague-Grundy"
date: "2026-02-09"
author: "OOI Oaxaca"
tags: ["c++", "teoría de juegos", "nim", "sprague-grundy", "competencias"]
syllabusId: 73
---

## ¿Qué es la teoría de juegos combinatoria?

**Analogía:** Imagina que juegas piedra, papel o tijera — eso es un juego de **azar**. Ahora imagina ajedrez: puedes analizar cada posición y determinar si hay una estrategia que **garantice** ganar. La teoría de juegos estudia esos juegos donde no hay azar, ambos jugadores ven todo, y gana quien haga el último movimiento válido.

En competencias, los juegos típicos tienen estas reglas:
1. Dos jugadores se alternan turnos
2. Ambos tienen información completa (no hay cartas ocultas)
3. No hay azar (no hay dados)
4. El jugador que **no puede mover** pierde
5. El juego siempre termina

## Posiciones ganadoras y perdedoras

Cada posición del juego es:
- **Posición ganadora (W):** El jugador que le toca mover tiene una estrategia para ganar.
- **Posición perdedora (L):** El jugador que le toca mover pierde si el oponente juega bien.

**Reglas clave:**
- Si **todas** las posiciones a las que puedo ir son W → estoy en L (no puedo escapar).
- Si **alguna** posición a la que puedo ir es L → estoy en W (mando al oponente a perder).

```
Ejemplo: Juego de las piedras
Hay N piedras. Cada turno puedes quitar 1, 2 o 3.
Pierde quien no pueda quitar.

N = 0: L (no puedes mover)
N = 1: W (quitas 1, dejas 0 = L al oponente)
N = 2: W (quitas 2, dejas 0 = L)
N = 3: W (quitas 3, dejas 0 = L)
N = 4: L (quites lo que quites, dejas 1, 2 o 3 = W al oponente)
N = 5: W (quitas 1, dejas 4 = L)
...

Patrón: L cuando N es múltiplo de 4
```

```cpp
// ¿Gana el primer jugador?
bool gana(int n) {
    return n % 4 != 0;
}
```

## Juego de Nim

El juego más importante de la teoría de juegos:
- Hay varias pilas de piedras.
- Cada turno, eliges una pila y quitas al menos 1 piedra de ella.
- Pierde quien no pueda mover.

### Teorema de Nim

La posición es **perdedora** si y solo si el XOR de todas las pilas es 0.

$$a_1 \oplus a_2 \oplus ... \oplus a_n = 0 \Rightarrow \text{Pierde el que mueve}$$

```cpp
bool ganaNim(vector<int> &pilas) {
    int xorTotal = 0;
    for (int p : pilas) xorTotal ^= p;
    return xorTotal != 0;
}
```

**¿Por qué funciona?**

1. La posición final (todas las pilas vacías) tiene XOR = 0 → es L ✓
2. Desde XOR ≠ 0, siempre puedes dejar XOR = 0 (hacer un movimiento ganador)
3. Desde XOR = 0, cualquier movimiento deja XOR ≠ 0

### Ejemplo

```
Pilas: 3, 4, 5
XOR: 3 ^ 4 ^ 5 = 011 ^ 100 ^ 101 = 010 = 2 ≠ 0
→ Gana el primer jugador

Estrategia: quitar 2 de la pila de 5 → pilas: 3, 4, 3
XOR: 3 ^ 4 ^ 3 = 4 ^ 0 = 4... Hmm, recalculemos:
3 ^ 3 = 0, 0 ^ 4 = 4. No.

Mejor: quitar 2 de la pila de 3 → pilas: 1, 4, 5
XOR: 1 ^ 4 ^ 5 = 001 ^ 100 ^ 101 = 000 = 0 ✓
```

## Sprague-Grundy

El teorema de Sprague-Grundy generaliza Nim a **cualquier juego**. Cada posición tiene un **valor de Grundy** (nimber):

$$g(p) = \text{mex}(\{g(p') : p' \text{ es un movimiento desde } p\})$$

Donde **mex** (minimum excludant) es el menor entero no negativo que NO está en el conjunto.

```
mex({0, 1, 2}) = 3
mex({0, 2, 3}) = 1
mex({1, 2}) = 0
mex({}) = 0
```

**La posición es perdedora si y solo si $g(p) = 0$.**

### Ejemplo: quitar 1 o 3 piedras

```
g(0) = mex({}) = 0          → L
g(1) = mex({g(0)}) = mex({0}) = 1  → W
g(2) = mex({g(1)}) = mex({1}) = 0  → L
g(3) = mex({g(2), g(0)}) = mex({0, 0}) = mex({0}) = 1  → W
g(4) = mex({g(3), g(1)}) = mex({1, 1}) = mex({1}) = 0  → L
g(5) = mex({g(4), g(2)}) = mex({0, 0}) = mex({0}) = 1  → W
```

Patrón: L cuando N es par.

```cpp
int grundy(int n, vector<int> &movimientos) {
    if (n == 0) return 0;

    set<int> alcanzables;
    for (int m : movimientos) {
        if (n >= m) {
            alcanzables.insert(grundy(n - m, movimientos));
        }
    }

    // Calcular mex
    int mex = 0;
    while (alcanzables.count(mex)) mex++;
    return mex;
}
```

### Juegos compuestos

Si tienes **varios juegos independientes** (como varias pilas), el Grundy total es el XOR de los valores individuales:

$$G_{total} = g_1 \oplus g_2 \oplus ... \oplus g_k$$

Esto es exactamente el Teorema de Nim generalizado.

```cpp
int grundyTotal(vector<int> &juegos) {
    int g = 0;
    for (int gi : juegos) g ^= gi;
    return g;
    // g == 0 → pierde el que mueve
}
```

## Calcular Grundy con DP

```cpp
const int MAXN = 100005;
int dp[MAXN];

void calcularGrundy(int maxN, vector<int> &movs) {
    dp[0] = 0;

    for (int n = 1; n <= maxN; n++) {
        set<int> alcanzables;
        for (int m : movs) {
            if (n >= m) alcanzables.insert(dp[n - m]);
        }

        int mex = 0;
        while (alcanzables.count(mex)) mex++;
        dp[n] = mex;
    }
}
```

<Callout type="info">
Siempre calcula los primeros valores de Grundy e intenta encontrar un **patrón**. Muchos juegos tienen patrones periódicos.
</Callout>

## Problema ejemplo

Hay N pilas. En cada turno puedes quitar 1, 2 o 4 piedras de una pila. ¿Gana el primer jugador?

```cpp
#include <iostream>
#include <vector>
#include <set>
using namespace std;

int grundy[100005];

int main() {
    // Precalcular Grundy para una pila
    grundy[0] = 0;
    for (int n = 1; n <= 100000; n++) {
        set<int> s;
        if (n >= 1) s.insert(grundy[n-1]);
        if (n >= 2) s.insert(grundy[n-2]);
        if (n >= 4) s.insert(grundy[n-4]);
        int mex = 0;
        while (s.count(mex)) mex++;
        grundy[n] = mex;
    }

    int n;
    cin >> n;

    int xorTotal = 0;
    for (int i = 0; i < n; i++) {
        int p;
        cin >> p;
        xorTotal ^= grundy[p];
    }

    cout << (xorTotal != 0 ? "First" : "Second") << endl;

    return 0;
}
```

## Ejercicio

Dos jugadores alternan. Hay N piedras. Puedes quitar cualquier potencia de 2 (1, 2, 4, 8, ...). ¿Quién gana?

<details>
<summary>Ver solución</summary>

Calculamos Grundy:
```
g(0) = 0
g(1) = mex({g(0)}) = mex({0}) = 1
g(2) = mex({g(1), g(0)}) = mex({1, 0}) = 2
g(3) = mex({g(2), g(1)}) = mex({2, 1}) = 0
g(4) = mex({g(3), g(2), g(0)}) = mex({0, 2, 0}) = mex({0, 2}) = 1
g(5) = mex({g(4), g(3), g(1)}) = mex({1, 0, 1}) = mex({0, 1}) = 2
g(6) = mex({g(5), g(4), g(2)}) = mex({2, 1, 2}) = mex({1, 2}) = 0
```

Patrón: 0, 1, 2, 0, 1, 2, ... → `g(n) = n % 3`.

El primer jugador pierde cuando `n % 3 == 0`.

```cpp
#include <iostream>
using namespace std;

int main() {
    int n;
    cin >> n;
    cout << (n % 3 != 0 ? "First" : "Second") << endl;
    return 0;
}
```

</details>
